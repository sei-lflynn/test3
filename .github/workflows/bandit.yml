# Bandit security scan (native SARIF) with hardening and reproducibility
# =============================================================================
# What this workflow does (high-level):
#   1) Checks out code with read-only permissions and no persisted credentials.
#   2) Sets up a pinned Python toolchain. Enables pip cache only if dependency
#      files are detected (prevents cache errors in tiny repos).
#   3) Installs a pinned Bandit version with the SARIF formatter enabled
#      (bandit[sarif] → makes --format sarif valid).
#   4) Runs Bandit recursively and writes SARIF results.
#   5) Uploads SARIF to GitHub Code Scanning; also stores it as a build artifact.
#
# Why these patterns (best practices recap):
#   • Default-deny permissions at the workflow level; elevate only where needed.
#   • Pin third-party actions to commit SHAs for tamper-resistance and reproducibility.
#   • Guard untrusted PRs: use pull_request (not pull_request_target).
#   • Concurrency cancels superseded runs to avoid CI pile-ups.
#   • Timeouts cap spend and fail fast.
#   • Hardened egress: start with audit; later switch to block + allowlist.
#   • Scoped checkout creds: no persisted token since we don’t push.
#   • Explicit runner + pinned tool versions → deterministic builds.
#   • Results are auditable: SARIF uploaded to Code Scanning and saved as an artifact.

name: Bandit

on:
  # Run when Python code or Bandit config changes on main.
  push:
    branches: [ "main" ]
    paths:
      - "**/*.py"
      - "pyproject.toml"
      - "poetry.lock"
      - "requirements*.txt"
      - "setup.cfg"
      - ".bandit"
      - "bandit.yaml"
      - "bandit.yml"
      - ".github/workflows/bandit.yml"
  # Evaluate untrusted PRs safely (no secrets beyond minimal job scope).
  pull_request:
    branches: [ "main" ]
    paths:
      - "**/*.py"
      - "pyproject.toml"
      - "poetry.lock"
      - "requirements*.txt"
      - "setup.cfg"
      - ".bandit"
      - "bandit.yaml"
      - "bandit.yml"
      - ".github/workflows/bandit.yml"
  # Optional weekly run; useful as a backstop.
  schedule:
    - cron: "37 14 * * 1"
  # Manual runs from the Actions tab for quick testing.
  workflow_dispatch:

# Cancel older in-flight runs for the same ref/PR to save time and CI minutes.
concurrency:
  group: ${{ github.workflow }}-${{ github.ref || github.run_id }}
  cancel-in-progress: true

# Default-deny at the workflow level (read-only). Jobs can elevate if needed.
permissions:
  contents: read

jobs:
  bandit:
    name: Bandit scan → SARIF
    runs-on: ubuntu-24.04            # Pin runner for reproducibility
    timeout-minutes: 15              # Cap total runtime (fail fast)

    # Least-privilege job permissions:
    # - contents: read        → needed for checkout
    # - security-events: write→ needed to upload SARIF to Code Scanning
    # - actions: read         → required in private repos for upload-sarif to read run status
    permissions:
      contents: read
      security-events: write
      actions: read

    # Centralized knobs so maintenance is easy.
    env:
      BANDIT_VERSION: "1.8.6"        # >=1.7.8 supports SARIF via the 'sarif' extra
      SARIF_OUT: "reports/bandit.sarif"

    steps:
      # Harden runner egress to reduce exfiltration risk if a step is compromised.
      # Start with 'audit' to learn what's accessed; switch to 'block' + allowlist later.
      - name: Harden runner (egress audit)
        uses: step-security/harden-runner@ec9f2d5744a09debf3a187a3f4f675c53b671911 # v2.13.0
        with:
          egress-policy: audit
          # When stable, prefer:
          # egress-policy: block
          # allowed-endpoints: >
          #   pypi.org:443
          #   files.pythonhosted.org:443
          #   api.github.com:443
          #   uploads.github.com:443
          #   objects.githubusercontent.com:443
          #   github.com:443

      # Checkout with no persisted credentials; we don't push in this job.
      - name: Checkout repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          persist-credentials: false
          fetch-depth: 0               # Full history (safe default; improves blame if needed)

      # Detect dependency files first; only enable pip cache if they exist.
      # This avoids setup-python's "No file matched" error in tiny repos without lockfiles.
      - name: Detect dependency files for pip cache
        id: deps
        shell: bash
        run: |
          set -euo pipefail
          shopt -s globstar nullglob
          files=( **/requirements*.txt **/pyproject.toml **/poetry.lock **/setup.cfg )
          if [ ${#files[@]} -gt 0 ]; then
            echo "have_deps=true" >> "$GITHUB_OUTPUT"
            {
              echo "paths<<EOF"
              printf '%s\n' "${files[@]}"
              echo "EOF"
            } >> "$GITHUB_OUTPUT"
            printf 'Dependency files detected:\n'; printf '  - %s\n' "${files[@]}"
          else
            echo "have_deps=false" >> "$GITHUB_OUTPUT"
            echo "No dependency files; Python will be set up without pip cache."
          fi

      # Use pip cache only when dependency files exist.
      - name: Set up Python (with pip cache)
        if: ${{ steps.deps.outputs.have_deps == 'true' }}
        uses: actions/setup-python@a26af69be951a213d495a4c3e4e4022e16d87065 # v5.6.0
        with:
          python-version: "3.12"
          cache: "pip"
          cache-dependency-path: ${{ steps.deps.outputs.paths }}

      # Fallback: plain Python setup (no cache).
      - name: Set up Python (exact patch)
        uses: actions/setup-python@a26af69be951a213d495a4c3e4e4022e16d87065 # v5.6.0
        with:
          python-version: "3.12.5"

      - name: Install Bandit (ephemeral hash-lock; fixed)
        shell: bash
        env:
          PIP_DISABLE_PIP_VERSION_CHECK: "1"
          PIP_INDEX_URL: "https://pypi.org/simple"
          BANDIT_VERSION: "1.8.6"
        run: |
          set -euo pipefail
          tmp="$(mktemp -d)"
          # 1) Download exact artifacts for this env (wheels preferred)
          python -m pip download --only-binary=:all: -d "$tmp" "bandit[sarif,toml]==${BANDIT_VERSION}"
          # 2) Build a lock file from artifacts ONLY (never include the lock itself)
          lock="$tmp/lock.txt"; : > "$lock"
          while IFS= read -r f; do
            h="$(sha256sum "$f" | awk '{print $1}')"
            printf 'file://%s --hash=sha256:%s\n' "$f" "$h" >> "$lock"
          done < <(find "$tmp" -maxdepth 1 -type f \( -name '*.whl' -o -name '*.tar.gz' -o -name '*.zip' \) | sort)
          # 3) Offline, hash-verified install
          python -m pip install --no-index --require-hashes -r "$lock"
          bandit --version
        timeout-minutes: 5


      # Run Bandit with native SARIF output.
      # --exit-zero keeps CI green; remove it to enforce gating (failing on findings).
      # --exclude skips common noisy directories; adjust to your repo.
      - name: Run Bandit → SARIF
        shell: bash
        run: |
          set -euxo pipefail
          mkdir -p "$(dirname "${SARIF_OUT}")"
          bandit -r . \
            --format sarif \
            --output "${SARIF_OUT}" \
            --severity-level all \
            --confidence-level all \
            --exit-zero \
            --quiet \
            --exclude .git,.venv,venv,.tox,site-packages,dist,build
        timeout-minutes: 5

      # Publish SARIF to GitHub Code Scanning (Security tab). Category keeps tools distinct.
      - name: Upload SARIF to Code Scanning
        uses: github/codeql-action/upload-sarif@3c3833e0f8c1c83d449a7478aa59c036a9165498 # v3.29.11
        with:
          sarif_file: ${{ env.SARIF_OUT }}
          category: bandit

      # Keep an auditable copy of the SARIF with explicit retention; never upload secrets.
      - name: Upload SARIF as artifact
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: bandit-sarif
          path: ${{ env.SARIF_OUT }}
          retention-days: 14
